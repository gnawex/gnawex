searchNodes=[{"doc":"","ref":"gnawex.html","title":"GNAWEX","type":"extras"},{"doc":"There isn't much to setup here since GNAWEX is still in its infancy. I'm currently working on the database side of things before I start working on the application-level, since PostgreSQL is surprisingly powerful, more than I definitely expected.","ref":"setup.html","title":"Setup","type":"extras"},{"doc":"I'm using version 14.1 of PostgreSQL, although 14.x should be fine. I don't guarantee backwards compatibility with &lt;14 because it's tiring. Creating gnawex_db If you're using NixOS, you're in luck. In your configuration.nix file, just add this: services.postgresql = { enable = true; package = pkgs.postgresql_14; authentication = pkgs.lib.mkOverride 14 '' local all all trust host all all localhost trust host all all ::1/128 trust ''; }; This sets up a PostgreSQL server with a default user postgres (no password). You can create a user/role that matches with your OS' user so that you don't need to keep appending psql / sqitch commands with -U postgres , and --db-user postgres respectively. We'll get to what sqitch is in a bit. My OS user is sekun . Replace sekun with whatever yours is. $ psql -U postgres postgres# CREATE ROLE sekun SUPERUSER CREATEDB CREATEROLE LOGIN; CREATE ROLE This creates a passwordless role sekun . Now you can use psql / sqitch without specifying the postgres user. This project needs a database called gnawex_db . Create one with this: createdb gnawex_db . Applying migrations For schema migrations, I'm using sqitch out of convenience. If you're using nix , it should already be a part of the nix dev shell environment (how convenienit). If you're using something else, check out their website for installation instructions. sqitch is interested in 3 folders: deploy , revert , and verify . deploy contains the migration scripts that you want to apply. revert when you want to rollback, and verify checks if things were applied as you expect them to be. These scripts are just plain SQL. Whatever is considered valid by PostgreSQL is fine. By this stage, it is assumed that you've setup PostgreSQL 14.1, created gnawex_db , and have sqitch installed. Example [sekun@nixos:~/Projects/gnawex]$ sqitch deploy Deploying changes to db:pg:gnawex_db + pgcrypto .......... ok + citext ............ ok + pgtap ............. ok + app_schema ........ ok + users ............. ok + items ............. ok + listings .......... ok + transactions ...... ok + match_listings .... ok + roles ............. ok + role_permissions .. ok If ever something goes wrong, it'll revert it to the last change that succeeded. But that's what it looks like if all goes well. Viewing migration statuses To see what migration sqitch has applied, you can use sqitch status : [ sekun @nixos : ~ / Projects / gnawex ] $ sqitch status # On database db:pg:gnawex_db # Project: gnawex # Change: 117b3847f4e26b654dcd925378ef7ff4810fd641 # Name: role_permissions # Deployed: 2022-03-08 16:20:32 +0800 # By: sekun &lt;sekun@nixos&gt; # Nothing to deploy ( up - to - date ) Here it tells you that the latest change is role_permissions . Which is good because at the time of writing, this is the latest migration we want. If you want to see the list of migrations planned, you can use sqitch plan : # Project: gnawex # File: sqitch.plan Deploy 3 d07e4afe1abd5eb6fbd5e350650da0535f89ccc Name : pgcrypto Planner : sekun &lt; sekun @nixos &gt; Date : 2022 - 03 - 08 11 : 53 : 13 + 0800 For encryption Deploy 895451 e8c444a571ae42a040d6496c14be5e6240 Name : citext Planner : sekun &lt; sekun @nixos &gt; Date : 2022 - 03 - 08 11 : 53 : 41 + 0800 For case - insensitive text Deploy 66 bda001775a8d943894a15e9745a1cd985cfdbd Name : pgtap Planner : sekun &lt; sekun @nixos &gt; Date : 2022 - 03 - 08 11 : 54 : 07 + 0800 For pg unit tests Deploy ea57600af26c2141dd329660db853152453ff934 Name : app_schema Planner : sekun &lt; sekun @nixos &gt; Date : 2022 - 03 - 08 12 : 02 : 39 + 0800 GNAWEX app schema Deploy cc0ce225344b889bcb8d42db3b501b8cca714f0e Name : users Planner : sekun &lt; sekun @nixos &gt; Date : 2022 - 03 - 08 12 : 04 : 23 + 0800 GNAWEX users Deploy afb388906019a2959b671c76f625e939077a5848 Name : items Planner : sekun &lt; sekun @nixos &gt; Date : 2022 - 03 - 08 14 : 56 : 21 + 0800 Items that can be traded Deploy dbd0e796eacee0ef094baa45ffee698f760e541f Name : listings ... Rolling back migrations sqitch revert WIP pgAdmin pgAdmin can be pretty useful, and I personally use it for EXPLAIN to understand the query planner better. You can either set it up manually, or use nix. # At the project root, `gnawex/` # Run the nix shell. If you&#39;re using nix-direnv, then it should automatically # load the environment for you. So you can skip this, if ever. nix develop # If you&#39;re using sudo, replace doas with sudo doas pgadmin4 You'll need elevated privileges since pgadmin needs write permissions in /var/lib/pgadmin . Doing this for the first time will ask for credentials you want to set, it doesn't really matter since it's just for a dev env, just remember it. You should see something like this: sekun@nixos ~/P/gnawex (main) [1]&gt; doas pgadmin4 doas (sekun@nixos) password: NOTE: Configuring authentication for SERVER mode. Enter the email address and password to use for the initial pgAdmin user account: Email address: postgres@example.com Password: Retype password: Starting pgAdmin 4. Please navigate to http://127.0.0.1:5050 in your browser. 2022-03-01 12:12:37,060: WARNING werkzeug: WebSocket transport not available. Install eventlet or gevent and gevent-websocket for improved performance. * Serving Flask app &#39;pgadmin&#39; (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off pgadmin should be available in the URL specified above. In my case, it's http://127.0.0.1:5050.","ref":"setup.html#database","title":"Setup - Database","type":"extras"},{"doc":"In the future, I'm going to rely on Makefile instead of fish scripts since it's tedious to manually load the script into the environment. For these scripts to work, you need psql and postgresql setup. psql comes with postgresql .","ref":"available-scripts.html","title":"Available scripts","type":"extras"},{"doc":"Takes all migration files from migrations/ , and loads it in gnawex_db . # This is pretty much it migrate","ref":"available-scripts.html#migrate","title":"Available scripts - migrate","type":"extras"},{"doc":"seed-db expects 1 argument, which can either be dev , or prod . If you're using this for a dev environment, use dev , otherwise if it's for production then use prod . You know how it goes. The seed files are in seeds/ as .csv with headers, and delimited with , . Here are the files those two look for: seed-db dev seeds/users.csv : Dummy users seeds/items.csv : Tradable MouseHunt items seeds/listings.csv : Dummy listings seed-db prod : TODO","ref":"available-scripts.html#seed-db","title":"Available scripts - seed-db","type":"extras"},{"doc":"Drops gnawex_db .","ref":"available-scripts.html#drop-db","title":"Available scripts - drop-db","type":"extras"},{"doc":"This is a convenience function that resets gnawex_db . drop-db createdb gnawex_db --user postgres migrate seed-db dev # Or you could just run this: reset-db","ref":"available-scripts.html#reset-db","title":"Available scripts - reset-db","type":"extras"},{"doc":"Roles are used to determine who can perform what operation in GNAWEX. Name Description authenticator The entrypoint role that GNAWEX starts with. anon The role that GNAWEX will switch to when the user is not authenticated. verified_user The role that GNAWEX will switch to when the user is authenticated, and verified. banned_user The role that GNAWEX will switch to when the user is authenticated, but banned. auth Role that owns the auth schema. api Role that owns the api schema.","ref":"roles.html","title":"Roles","type":"extras"},{"doc":"These ones are defined with CREATE TYPE ROLE as ENUM (...) . These are the roles you'll see in GNAWEX. So far, none of these roles were worked on since the DB is still actively worked on. Although, here is what I have in mind: admin : The system administrator Can appoint moderators Maintain items Privileges like banning/unbanning users and mods mod : Moderates the platform user : Traders, basically Anything the user can do, the mod and admin can as well. So all roles here are able to create listings.","ref":"roles.html#user-roles","title":"Roles - User roles","type":"extras"},{"doc":"Database roles exist because I'm deferring authorization to Postgres. You can get the list of roles in the DB by running this in psql : \\du ; and this would show something like this: gnawex_db =&gt; \\ du List of roles Role name | Attributes | Member of -- -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- + -- -- -- -- -- -- -- anon | Cannot login | { } authenticator | No inheritance | { anon } gnawex_merchant | Cannot login , Bypass RLS | { anon } postgres | Superuser , Create role , Create DB , Replication , Bypass RLS | { } sekun | | { valid_user } valid_user | Cannot login | { } Here's a summary of what each of them does: anon : Public role. Can view listings, and items. authenticator : Role that is used to login. This role is still being worked on to really flesh out what it's supposed to do. gnawex_merchant : This isn't meant for anyone, rather this role is used to facilitate the exchanging of two listings. Since normal users cannot update their own listings, much more other people's listings, a special role needs to exist for that. You can think of it as GNAWEX updating the listings in your behalf when your listing gets matched with another. postgres : The highest role achievable. Can do anything. sekun : An example of a valid_user . You can ignore this since I just use this for testing. valid_user : This role is granted to users that are: 1) verified, and 2) not banned.","ref":"roles.html#database-roles","title":"Roles - Database roles","type":"extras"}]